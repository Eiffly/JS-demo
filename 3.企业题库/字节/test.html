<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //第一种方式 通过原型链将数据存储在foo.arr里面
        //#region 
        // var foo = function (...args) {
        //     if (!Array.isArray(foo.arr)) {
        //         foo.arr = []
        //     }
        //     foo.arr.push(...args)
        //     return foo
        // }
        // Function.prototype.getValue = () => {
        //     return foo.arr.reduce((pre, cur) => {
        //         return pre + cur
        //     }, 0)
        // }

        // // var f1 = foo(1, 2, 3)
        // // f1.getValue()
        // var f2 = foo(1)(2, 3)
        // f2.getValue()
        // // var f3 = foo(1)(2)(3)(4)
        // f3.getValue()
        //#endregion

        //第二种方式：通过闭包
        // var foo = function (...args) {
        //     const fn = function () {
        //         //Array.prototype.slice.call(arguments)的具体含义： https://www.cnblogs.com/papi/p/9234964.html
        //         const arg1 = Array.prototype.slice.call(arguments)
        //         args = args.concat(arg1)
        //         return foo(...args)
        //     }
        //     fn.getValue = () => {
        //         //当通过箭头函数的方法调用的时候，由于箭头函数没有自己的this，this表示的是window
        //         //当通过function的方法调用的时候，this由于是以【方法】的形式调用的，this表示的是fn这个函数
        //         console.log(this);
        //         return args.reduce((pre, cur) => pre + cur, 0)
        //     }
        //     return fn
        // }

        // var f1 = foo(1, 2, 3)
        // var f2 = foo(1)(2, 3)
        // var f3 = foo(1)(2)(3)(4)
        // f1.getValue()
        // f2.getValue()
        // f3.getValue()

      



    </script>
</body>

</html>